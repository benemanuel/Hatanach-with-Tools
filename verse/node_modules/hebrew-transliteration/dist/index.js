var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Schema: () => Schema,
  Text: () => import_havarotjs3.Text,
  remove: () => remove,
  sequence: () => sequence,
  transliterate: () => transliterate
});
module.exports = __toCommonJS(src_exports);
var import_havarotjs3 = require("havarotjs");

// src/sequence.ts
var import_havarotjs = require("havarotjs");
var vowels = /[\u{05B0}-\u{05BD}\u{05BF}\u{05C7}]/u;
var sequence = (text, qametsQatan = false) => {
  return vowels.test(text) ? new import_havarotjs.Text(text, { qametsQatan }).text : text;
};

// src/rules.ts
var import_cluster = require("havarotjs/dist/cluster");

// src/hebCharsTrans.ts
var transliterateMap = {
  "\u05B0": "VOCAL_SHEVA",
  "\u05B1": "HATAF_SEGOL",
  "\u05B2": "HATAF_PATAH",
  "\u05B3": "HATAF_QAMATS",
  "\u05B4": "HIRIQ",
  "\u05B5": "TSERE",
  "\u05B6": "SEGOL",
  "\u05B7": "PATAH",
  "\u05B8": "QAMATS",
  "\u05B9": "HOLAM",
  "\u05BA": "HOLAM",
  "\u05BB": "QUBUTS",
  "\u05BC": "DAGESH",
  "\u05BE": "MAQAF",
  "\u05C0": "PASEQ",
  "\u05C3": "SOF_PASUQ",
  "\u05C7": "QAMATS_QATAN",
  \u05D0: "ALEF",
  \u05D1: "BET",
  \u05D2: "GIMEL",
  \u05D3: "DALET",
  \u05D4: "HE",
  \u05D5: "VAV",
  \u05D6: "ZAYIN",
  \u05D7: "HET",
  \u05D8: "TET",
  \u05D9: "YOD",
  \u05DA: "FINAL_KAF",
  \u05DB: "KAF",
  \u05DC: "LAMED",
  \u05DD: "FINAL_MEM",
  \u05DE: "MEM",
  \u05DF: "FINAL_NUN",
  \u05E0: "NUN",
  \u05E1: "SAMEKH",
  \u05E2: "AYIN",
  \u05E3: "FINAL_PE",
  \u05E4: "PE",
  \u05E5: "FINAL_TSADI",
  \u05E6: "TSADI",
  \u05E7: "QOF",
  \u05E8: "RESH",
  \u05E9: "SHIN",
  \u05EA: "TAV"
};

// src/mapChars.ts
var mapChars = (text, schema) => [...text].map((char) => char in transliterateMap ? schema[transliterateMap[char]] : char).join("");

// src/rules.ts
var taamim = /[\u{0590}-\u{05AF}\u{05BD}\u{05BF}]/u;
var changeElementSplit = (input, split, join) => input.split(split).join(join);
var consonantFeatures = (clusterText, syl, cluster, schema) => {
  var _a;
  if ((_a = schema.ADDITIONAL_FEATURES) == null ? void 0 : _a.length) {
    const clusterSeqs = schema.ADDITIONAL_FEATURES.filter((s) => s.FEATURE === "cluster");
    for (const seq of clusterSeqs) {
      const heb = new RegExp(seq.HEBREW, "u");
      if (heb.test(clusterText)) {
        const sylSeq = changeElementSplit(clusterText, heb, seq.TRANSLITERATION);
        return [...sylSeq].map((char) => mapChars(char, schema)).join("");
      }
    }
  }
  clusterText = cluster.hasShewa && syl.isClosed ? clusterText.replace(/\u{05B0}/u, "") : clusterText;
  if (/??\u{05BC}$/mu.test(clusterText)) {
    return changeElementSplit(clusterText, /??\u{05BC}/u, schema.HE);
  }
  if (syl.isFinal && !syl.isClosed) {
    const furtiveChet = /\u{05D7}\u{05B7}$/mu;
    if (furtiveChet.test(clusterText)) {
      return changeElementSplit(clusterText, furtiveChet, "\u05B7\u05D7");
    }
    const furtiveAyin = /\u{05E2}\u{05B7}$/mu;
    if (furtiveAyin.test(clusterText)) {
      return changeElementSplit(clusterText, furtiveAyin, "\u05B7\u05E2");
    }
    const furtiveHe = /\u{05D4}\u{05BC}\u{05B7}$/mu;
    if (furtiveHe.test(clusterText)) {
      return changeElementSplit(clusterText, furtiveHe, "\u05B7\u05D4\u05BC");
    }
  }
  const prevHasVowel = cluster.prev instanceof import_cluster.Cluster ? cluster.prev.hasVowel : false;
  const isDoubled = schema.DAGESH_CHAZAQ && prevHasVowel && /\u{05BC}/u.test(clusterText);
  if (schema.BET_DAGESH && /??\u{05BC}/u.test(clusterText)) {
    return changeElementSplit(clusterText, /??\u{05BC}/u, schema.BET_DAGESH.repeat(isDoubled ? 2 : 1));
  }
  if (schema.GIMEL_DAGESH && /??\u{05BC}/u.test(clusterText)) {
    return changeElementSplit(clusterText, /??\u{05BC}/u, schema.GIMEL_DAGESH.repeat(isDoubled ? 2 : 1));
  }
  if (schema.DALET_DAGESH && /??\u{05BC}/u.test(clusterText)) {
    return changeElementSplit(clusterText, /??\u{05BC}/u, schema.DALET_DAGESH.repeat(isDoubled ? 2 : 1));
  }
  if (schema.KAF_DAGESH && /??\u{05BC}/u.test(clusterText)) {
    return changeElementSplit(clusterText, /??\u{05BC}/u, schema.KAF_DAGESH.repeat(isDoubled ? 2 : 1));
  }
  if (schema.KAF_DAGESH && /??\u{05BC}/u.test(clusterText)) {
    return changeElementSplit(clusterText, /??\u{05BC}/u, schema.KAF_DAGESH.repeat(isDoubled ? 2 : 1));
  }
  if (schema.PE_DAGESH && /??\u{05BC}/u.test(clusterText)) {
    return changeElementSplit(clusterText, /??\u{05BC}/u, schema.PE_DAGESH.repeat(isDoubled ? 2 : 1));
  }
  if (schema.TAV_DAGESH && /??\u{05BC}/u.test(clusterText)) {
    return changeElementSplit(clusterText, /??\u{05BC}/u, schema.TAV_DAGESH.repeat(isDoubled ? 2 : 1));
  }
  if (/??\u{05C1}/u.test(clusterText)) {
    return changeElementSplit(clusterText, /??\u{05C1}/u, schema.SHIN.repeat(isDoubled ? 2 : 1));
  }
  if (/??\u{05C2}/u.test(clusterText)) {
    return changeElementSplit(clusterText, /??\u{05C2}/u, schema.SIN.repeat(isDoubled ? 2 : 1));
  }
  if (isDoubled) {
    const consonant = cluster.chars[0].text;
    const consonantDagesh = new RegExp(consonant + "\u05BC", "u");
    return changeElementSplit(clusterText, consonantDagesh, `${consonant + consonant}`);
  }
  if (cluster.isShureq) {
    return schema.SHUREQ;
  }
  return clusterText;
};
var materFeatures = (syl, schema) => {
  const mater = syl.clusters.filter((c) => c.isMater)[0];
  const prev = mater.prev instanceof import_cluster.Cluster ? mater.prev : null;
  const materText = mater.text;
  const prevText = ((prev == null ? void 0 : prev.text) || "").replace(taamim, "");
  let noMaterText = syl.clusters.filter((c) => !c.isMater).map((c) => consonantFeatures(c.text.replace(taamim, ""), syl, c, schema)).join("");
  const hasMaqaf = mater.text.includes("\u05BE");
  noMaterText = hasMaqaf ? noMaterText.concat("\u05BE") : noMaterText;
  if (/??/.test(materText)) {
    if (/\u{05B4}/u.test(prevText)) {
      return changeElementSplit(noMaterText, /\u{05B4}/u, schema.HIRIQ_YOD);
    }
    if (/\u{05B5}/u.test(prevText)) {
      return changeElementSplit(noMaterText, /\u{05B5}/u, schema.TSERE_YOD);
    }
    if (/\u{05B6}/u.test(prevText)) {
      return changeElementSplit(noMaterText, /\u{05B6}/u, schema.SEGOL_YOD);
    }
  }
  if (/??/u.test(materText)) {
    if (/\u{05B9}/u.test(prevText)) {
      return changeElementSplit(noMaterText, /\u{05B9}/u, schema.HOLAM_VAV);
    }
  }
  if (/??/.test(materText)) {
    if (/\u{05B8}/u.test(prevText)) {
      return changeElementSplit(noMaterText, /\u{05B8}/u, schema.QAMATS_HE);
    }
    if (/\u{05B6}/u.test(prevText)) {
      return changeElementSplit(noMaterText, /\u{05B6}/u, schema.SEGOL_HE);
    }
    if (/\u{05B5}/u.test(prevText)) {
      return changeElementSplit(noMaterText, /\u{05B5}/u, schema.SEGOL_HE);
    }
  }
  return materText;
};
var joinChars = (isAccented, sylChars, schema) => {
  if (!isAccented) {
    return sylChars.map((char) => mapChars(char, schema)).join("");
  }
  if (schema.STRESS_MARKER) {
    const location = schema.STRESS_MARKER.location;
    const mark = schema.STRESS_MARKER.mark;
    if (location === "before-syllable") {
      return `${mark}${sylChars.map((char) => mapChars(char, schema)).join("")}`;
    }
    if (location === "after-syllable") {
      return `${sylChars.map((char) => mapChars(char, schema)).join("")}${mark}`;
    }
    const vowels3 = [
      schema.PATAH,
      schema.HATAF_PATAH,
      schema.QAMATS,
      schema.HATAF_QAMATS,
      schema.SEGOL,
      schema.HATAF_SEGOL,
      schema.TSERE,
      schema.HIRIQ,
      schema.HOLAM,
      schema.QAMATS_QATAN,
      schema.QUBUTS,
      schema.QAMATS_HE,
      schema.SEGOL_HE,
      schema.TSERE_HE,
      schema.HIRIQ_YOD,
      schema.TSERE_YOD,
      schema.SEGOL_YOD,
      schema.HOLAM_VAV,
      schema.SHUREQ
    ].sort((a, b) => b.length - a.length);
    const vowelRgx = new RegExp(`${vowels3.join("|")}`);
    const str = sylChars.map((char) => mapChars(char, schema)).join("");
    const match = str.match(vowelRgx);
    if (location === "before-vowel") {
      return (match == null ? void 0 : match.length) ? str.replace(match[0], `${mark}${match[0]}`) : str;
    }
    return (match == null ? void 0 : match.length) ? str.replace(match[0], `${match[0]}${mark}`) : str;
  }
  return sylChars.map((char) => mapChars(char, schema)).join("");
};
var sylRules = (syl, schema) => {
  var _a;
  const sylTxt = syl.text.replace(taamim, "");
  if ((_a = schema.ADDITIONAL_FEATURES) == null ? void 0 : _a.length) {
    const sylSeqs = schema.ADDITIONAL_FEATURES.filter((s) => s.FEATURE === "syllable");
    for (const seq of sylSeqs) {
      const heb = new RegExp(seq.HEBREW, "u");
      if (heb.test(sylTxt)) {
        const wordSeq = changeElementSplit(sylTxt, heb, seq.TRANSLITERATION);
        return joinChars(syl.isAccented, [...wordSeq], schema);
      }
    }
  }
  const mSSuffix = /\u{05B8}\u{05D9}\u{05D5}/u;
  if (syl.isFinal && mSSuffix.test(sylTxt)) {
    const sufxSyl = changeElementSplit(sylTxt, mSSuffix, schema.MS_SUFX);
    return joinChars(syl.isAccented, [...sufxSyl], schema);
  }
  const hasMater = syl.clusters.map((c) => c.isMater).includes(true);
  if (hasMater) {
    const materSyl = materFeatures(syl, schema);
    return joinChars(syl.isAccented, [...materSyl], schema);
  }
  const returnTxt = syl.clusters.map((cluster) => {
    const clusterText = cluster.text.replace(taamim, "");
    return consonantFeatures(clusterText, syl, cluster, schema);
  });
  return joinChars(syl.isAccented, returnTxt, schema);
};
var wordRules = (word, schema) => {
  var _a;
  if (word.isDivineName)
    return schema.DIVINE_NAME;
  if (word.hasDivineName)
    return `${sylRules(word.syllables[0], schema)}-${schema.DIVINE_NAME}`;
  if ((_a = schema.ADDITIONAL_FEATURES) == null ? void 0 : _a.length) {
    const wordSeqs = schema.ADDITIONAL_FEATURES.filter((s) => s.FEATURE === "word");
    for (const seq of wordSeqs) {
      const heb = new RegExp(seq.HEBREW, "u");
      const wordText = word.text.replace(taamim, "");
      if (heb.test(wordText)) {
        const wordSeq = changeElementSplit(wordText, heb, seq.TRANSLITERATION);
        return [...wordSeq].map((char) => mapChars(char, schema)).join("");
      }
    }
  }
  return word;
};

// src/schema.ts
var Schema = class {
  constructor(schema) {
    this.VOCAL_SHEVA = schema.VOCAL_SHEVA, this.HATAF_SEGOL = schema.HATAF_SEGOL, this.HATAF_PATAH = schema.HATAF_PATAH, this.HATAF_QAMATS = schema.HATAF_QAMATS, this.HIRIQ = schema.HIRIQ, this.TSERE = schema.TSERE, this.SEGOL = schema.SEGOL, this.PATAH = schema.PATAH, this.QAMATS = schema.QAMATS, this.HOLAM = schema.HOLAM, this.QUBUTS = schema.QUBUTS, this.DAGESH = schema.DAGESH, this.DAGESH_CHAZAQ = schema.DAGESH_CHAZAQ, this.MAQAF = schema.MAQAF, this.PASEQ = schema.PASEQ, this.SOF_PASUQ = schema.SOF_PASUQ, this.QAMATS_QATAN = schema.QAMATS_QATAN, this.FURTIVE_PATAH = schema.FURTIVE_PATAH, this.HIRIQ_YOD = schema.HIRIQ_YOD, this.TSERE_YOD = schema.TSERE_YOD, this.SEGOL_YOD = schema.SEGOL_YOD, this.SHUREQ = schema.SHUREQ, this.HOLAM_VAV = schema.HOLAM_VAV, this.QAMATS_HE = schema.QAMATS_HE, this.SEGOL_HE = schema.SEGOL_HE, this.TSERE_HE = schema.TSERE_HE, this.MS_SUFX = schema.MS_SUFX, this.ALEF = schema.ALEF, this.BET_DAGESH = schema.BET_DAGESH, this.BET = schema.BET, this.GIMEL = schema.GIMEL, this.GIMEL_DAGESH = schema.GIMEL_DAGESH, this.DALET = schema.DALET, this.DALET_DAGESH = schema.DALET_DAGESH, this.HE = schema.HE, this.VAV = schema.VAV, this.ZAYIN = schema.ZAYIN, this.HET = schema.HET, this.TET = schema.TET, this.YOD = schema.YOD, this.FINAL_KAF = schema.FINAL_KAF, this.KAF = schema.KAF, this.KAF_DAGESH = schema.KAF_DAGESH, this.LAMED = schema.LAMED, this.FINAL_MEM = schema.FINAL_MEM, this.MEM = schema.MEM, this.FINAL_NUN = schema.FINAL_NUN, this.NUN = schema.NUN, this.SAMEKH = schema.SAMEKH, this.AYIN = schema.AYIN, this.FINAL_PE = schema.FINAL_PE, this.PE = schema.PE, this.PE_DAGESH = schema.PE_DAGESH, this.FINAL_TSADI = schema.FINAL_TSADI, this.TSADI = schema.TSADI, this.QOF = schema.QOF, this.RESH = schema.RESH, this.SHIN = schema.SHIN, this.SIN = schema.SIN, this.TAV = schema.TAV, this.TAV_DAGESH = schema.TAV_DAGESH, this.DIVINE_NAME = schema.DIVINE_NAME, this.SYLLABLE_SEPARATOR = schema.SYLLABLE_SEPARATOR, this.ADDITIONAL_FEATURES = schema.ADDITIONAL_FEATURES, this.STRESS_MARKER = schema.STRESS_MARKER, this.longVowels = schema.longVowels, this.qametsQatan = schema.qametsQatan, this.sqnmlvy = schema.sqnmlvy, this.wawShureq = schema.wawShureq, this.article = schema.article;
  }
};
var SBL = class extends Schema {
  constructor(schema) {
    var _a, _b, _c, _d, _e, _f;
    super({
      VOCAL_SHEVA: schema.VOCAL_SHEVA || "\u01DD",
      HATAF_SEGOL: schema.HATAF_SEGOL || "\u0115",
      HATAF_PATAH: schema.HATAF_PATAH || "\u0103",
      HATAF_QAMATS: schema.HATAF_QAMATS || "\u014F",
      HIRIQ: schema.HIRIQ || "i",
      TSERE: schema.TSERE || "\u0113",
      SEGOL: schema.SEGOL || "e",
      PATAH: schema.PATAH || "a",
      QAMATS: schema.QAMATS || "\u0101",
      HOLAM: schema.HOLAM || "\u014D",
      QUBUTS: schema.QUBUTS || "\u016B",
      DAGESH: schema.DAGESH || "",
      DAGESH_CHAZAQ: (_a = schema.DAGESH_CHAZAQ) != null ? _a : true,
      MAQAF: schema.MAQAF || "-",
      PASEQ: schema.PASEQ || "",
      SOF_PASUQ: schema.SOF_PASUQ || "",
      QAMATS_QATAN: schema.QAMATS_QATAN || "o",
      FURTIVE_PATAH: schema.FURTIVE_PATAH || "a",
      HIRIQ_YOD: schema.HIRIQ_YOD || "\xEE",
      TSERE_YOD: schema.TSERE_YOD || "\xEA",
      SEGOL_YOD: schema.SEGOL_YOD || "\xEA",
      SHUREQ: schema.SHUREQ || "\xFB",
      HOLAM_VAV: schema.HOLAM_VAV || "\xF4",
      QAMATS_HE: schema.QAMATS_HE || "\xE2",
      SEGOL_HE: schema.SEGOL_HE || "\xEA",
      TSERE_HE: schema.TSERE_HE || "\xEA",
      MS_SUFX: schema.MS_SUFX || "\u0101yw",
      ALEF: schema.ALEF || "\u02BE",
      BET: schema.BET || "b",
      BET_DAGESH: schema.BET_DAGESH || void 0,
      GIMEL: schema.GIMEL || "g",
      GIMEL_DAGESH: schema.GIMEL_DAGESH || void 0,
      DALET: schema.DALET || "d",
      DALET_DAGESH: schema.DALET_DAGESH || void 0,
      HE: schema.HE || "h",
      VAV: schema.VAV || "w",
      ZAYIN: schema.ZAYIN || "z",
      HET: schema.HET || "\u1E25",
      TET: schema.TET || "\u1E6D",
      YOD: schema.YOD || "y",
      FINAL_KAF: schema.FINAL_KAF || "k",
      KAF: schema.KAF || "k",
      KAF_DAGESH: schema.KAF_DAGESH || void 0,
      LAMED: schema.LAMED || "l",
      FINAL_MEM: schema.FINAL_MEM || "m",
      MEM: schema.MEM || "m",
      FINAL_NUN: schema.FINAL_NUN || "n",
      NUN: schema.NUN || "n",
      SAMEKH: schema.SAMEKH || "s",
      AYIN: schema.AYIN || "\u02BF",
      FINAL_PE: schema.FINAL_PE || "p",
      PE: schema.PE || "p",
      PE_DAGESH: schema.PE_DAGESH || void 0,
      FINAL_TSADI: schema.FINAL_TSADI || "\u1E63",
      TSADI: schema.TSADI || "\u1E63",
      QOF: schema.QOF || "q",
      RESH: schema.RESH || "r",
      SHIN: schema.SHIN || "\u0161",
      SIN: schema.SIN || "\u015B",
      TAV: schema.TAV || "t",
      TAV_DAGESH: schema.TAV_DAGESH || void 0,
      DIVINE_NAME: schema.DIVINE_NAME || "yhwh",
      SYLLABLE_SEPARATOR: schema.SYLLABLE_SEPARATOR || void 0,
      ADDITIONAL_FEATURES: schema.ADDITIONAL_FEATURES || void 0,
      STRESS_MARKER: schema.STRESS_MARKER || void 0,
      longVowels: (_b = schema.longVowels) != null ? _b : true,
      qametsQatan: (_c = schema.qametsQatan) != null ? _c : true,
      sqnmlvy: (_d = schema.sqnmlvy) != null ? _d : true,
      wawShureq: (_e = schema.wawShureq) != null ? _e : true,
      article: (_f = schema.article) != null ? _f : true
    });
  }
};

// src/transliterate.ts
var import_havarotjs2 = require("havarotjs");
var import_word = require("havarotjs/dist/word");
var getSylOpts = (schema) => {
  const options = {};
  if ("longVowels" in schema)
    options.longVowels = schema.longVowels;
  if ("qametsQatan" in schema)
    options.qametsQatan = schema.qametsQatan;
  if ("sqnmlvy" in schema)
    options.sqnmlvy = schema.sqnmlvy;
  if ("wawShureq" in schema)
    options.wawShureq = schema.wawShureq;
  if ("article" in schema)
    options.article = schema.article;
  return options;
};
var transliterate = (text, schema) => {
  const transSchema = schema instanceof Schema ? schema : new SBL(schema != null ? schema : {});
  const isText = text instanceof import_havarotjs2.Text;
  if (!isText && !vowels.test(text)) {
    const sin = new RegExp(transSchema.SHIN + "\u05C2", "gu");
    return mapChars(text, transSchema).replace(sin, transSchema.SIN).replace(/\u{05C1}/gu, "");
  }
  const sylOptions = getSylOpts(transSchema != null ? transSchema : {});
  const newText = isText ? text : new import_havarotjs2.Text(text, sylOptions);
  return newText.words.map((word) => {
    var _a, _b;
    let transliteration = wordRules(word, transSchema);
    if (transliteration instanceof import_word.Word) {
      transliteration = word.syllables.map((s) => sylRules(s, transSchema)).join((_a = transSchema.SYLLABLE_SEPARATOR) != null ? _a : "");
    }
    return `${transliteration}${(_b = word.whiteSpaceAfter) != null ? _b : ""}`;
  }).join("");
};

// src/remove.ts
var cantillation = /[\u{0591}-\u{05AF}\u{05BF}\u{05C0}\u{05C3}-\u{05C6}\u{05F3}\u{05F4}]/gu;
var vowels2 = /[\u{05B0}-\u{05BD}\u{05BF}\u{05C7}]/gu;
var shinDot = /\u{05C1}/gu;
var sinDot = /\u{05C2}/gu;
var removeItem = (text, item) => text.replace(item, "");
var remove = (text, { removeVowels = false, removeShinDot = false, removeSinDot = false } = {}) => {
  const sequenced = sequence(text);
  const remCantillation = removeItem(sequenced, cantillation);
  const remVowels = removeVowels ? removeItem(remCantillation, vowels2) : remCantillation;
  const remShin = removeShinDot ? removeItem(remVowels, shinDot) : remVowels;
  return removeSinDot ? removeItem(remShin, sinDot) : remShin;
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Schema,
  Text,
  remove,
  sequence,
  transliterate
});


